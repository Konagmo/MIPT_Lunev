Signals
сущность похожая на прерывание
сколько сигналов отправлиб функция обработкико меньшее число раз
ос в нужный момент отправляет сигналы

пользователь может отправить сигналл вызовом kill
int kill(pid_t pid, int signo(номер сигнала))
signo = 0  - единственный способ проверить существование процесса
True если существует, он не вызывается(ничего не отправляется)
отправить сигнал процессу другого пользователя нельзя!
root может кому угодно

pid<0 - сигнал не одному а группе процессов с таким идентификатором
минус уберается и ид группы получается :)
pid = -1 - всем, кому можем отправить 

signal не стандартизирован -  не пользуемся
правильно - sigaction 
int sigaction(int signo, const struct sigaction *act,
	struct sigaction *old) - тот который был раньше мб NULL
=> .sa_handler = handler;

прерывания можно запрещать и разрешать
манипуляция разрешением сигналов - сис вызов sigprocmask
замаскировать какой-то сигнал
int sigprocmask(int how, const sigset_t *set, sigset_t *old)
sigset_t - абстрактный тип для работы с которым есть функции(int :D)

5 штук:
sigemptyset - занулить
sigfillset - заполнить
sigaddset - дополнить
sigdelset - убрать сигнал
sigsmember? - проверить что сигнал установлен

how: SIG_BLOCK SIG_UNBLOCK SIG_SETMASK
заблокировать, оставив все сигналы как раньше
разблокировать
целиком заменить маску

посмотреть какие сигналы выставлены, но ожидают
пришли, но еще не обработаны
sigpending

handler - SIG_DFL - по умолчанию, SIG_IGN - игнорировать его

pause();-заблокироваться пока сигнал не придет
race!! сигнал придет не тогда когда придет сис вызов
- он придет и уйдет, и мы заблокируемся навсегда - плохо
!!!
int sigsuspend(sigset_t *mask)
атомарная последовательность вызовов:
sigprocmask(
pause
sigprocmask(

отложенный способ доставки сигналов
alarm
int alarm(5) - число секунд
снять аларм alarm(0)
несколько алармов ставить нельзя(не получится)

Задача:
Прога рождает дочерний процесс.
Дочерний читает, родительский печатает
Коммуникация - через сигналы нельзя передавать в сигналах байтик
printf, scanf, write... внутри обработчика сигналов
Дочерний отправляет родительскому.
