polling - дорогая, много вызовов опрос прочитать-записать х2 и ожидание на слипе
2 system calls
poll & select - эквивалентны
select: 
int select(int fdmax, fd_set *readfd, fd_set *writefd, fd_set *except_fd
	struct timeout *timeout);
fdmax-максимальный дескриптор по номеру по которому мы раотаем +1
поспать какое-то кол-во микросекунд. NULL - спим вечно
fd_set - абстрактный тип с абстр операциями:
	FD_CLEAR
	FD_SET
	FD_ZERO
	FD_ISSET
берем фд-сет - зануляем его с помощью зеро
Для чтения и записи нужны разные сеты.
Множества модифицируются системными вызовами
Дескрипторы которые ожидаем
Возвращаем битики там, где мозможны ио-операции
epoll, eselect


FINAL_TASK
прога - 2 агрумента - кол-во процессов породить, имя файла,
 который нужно передать
Род процесс - взаимодействует с детьми
Дети из одно фд читать, в другой писать.
В детях - блокирующие
А родительский имеет кучу дескрипторов
Все дочерние процессы идентичны(см 1 задачу)
Родительский процесс должен одновременно читать и писать из всех фд что есть
Структура
	не раскладывать данные по пачкам массивов
	все что относится к одному соединению отец-дочь
		 лежало в одной структуре
	Буфера в процессах были не одинаковые
	Для 0 -> 3^n*4k, 1 -> 3^(n-1)*4k, 2 -> 3^(n-2)*4k ... 3^0*4k
		 - родительский процесс - чтение на такое количество байт
	Для чтения - буфер целиком
	Признак конца нельзя использовать количество переданных байт
Операции чтения записи могут быть частично успешниыми - не забывать
Нельзя 100 цпу
Однопоточный прокси
